#!/usr/bin/python
import numpy as np
import argparse
import sys
from bluedot import iouvspec

class LibRadtran:

    def __init__(self,inputfile,wcfile,wgfile):
        self.uvinput = "# libRadtran uvinput file generated by makeinput.py"+"\n"
        self.uvinput_file = inputfile #INPUT file 
        self.wc = "# libradtran wc file generated by makeinput.py"+"\n"
        self.wc_file = wcfile #WC file 
        self.wg_file = wgfile #wavelength grid file    
        
    def write(self, com, val=None):
        if val == None:
            self.uvinput = self.uvinput+com+"\n"
        else:
            self.uvinput = self.uvinput+com+str(val)+"\n"

    def solver(self,solver):
        self.write("rte_solver "+solver)

    def pseudospherical(self):
        self.write("pseudospherical")


    def default(self, default_uvinput):
        com = "# default uvinput file = "+default_uvinput+"\n"
        self.write(com)
        f = open(default_uvinput)
        com = f.read()
        f.close()
        com = com+"\n"
        self.write(com)

    def angles(self, sza, vza, aza):
        # uvinput angle: sza,vza,aza in radian
        # ------------------------------------
        # sza: # Solar zenith angle in degree, from file
        # phi: #Azimuth output angles (in degrees) in increasing order.
        # umu: #Cosine of output polar angles in increasing order, starting with negative (down- welling radiance, looking upward) values (if any) and on through positive (upwelling radiance, looking downward) values. Must not be zero.
        # ------------------------------------
        self.write("# angles")
        self.write("sza   ", sza*180.0/np.pi)
        self.write("phi   ", aza*180.0/np.pi)
        self.write("umu   ", np.cos(vza))

    def rossli(self, fiso, fvol, fgeo):
        # BRDF data for DISORT 3 test
        self.write("# Ross-Li model BRDF parameters")
        self.write("brdf_ambrals iso   ", fiso)
        self.write("brdf_ambrals vol   ", fvol)
        self.write("brdf_ambrals geo   ", fgeo)
        self.write("brdf_ambrals_hotspot")

    def ocean(self, uvel=10.0):
        self.write("brdf_cam u10 "+str(uvel))

    def const_albedo(self, albedoin=0.0):
        if albedoin > 1.0:
            albedoin = 1.0
        elif albedoin < 0.0:
            albedoin = 0.0
        self.write("albedo "+str(albedoin))

    def savewc(self,z,LWC,R_eff):
        self.write("wc_file 1D "+self.wc_file)
        np.savetxt(self.wc_file, np.array([z, LWC, R_eff]).transpose(
        ), header="z[km] LWC[g/m^3] R_eff[um]", fmt='%10.4f')

    def savewg(self,wavegrid):
        self.write("wavelength_grid_file "+self.wg_file)
        f = open(self.wg_file,"w")
        for iw in wavegrid:
            f.write(str(iw)+"\n")
        f.close()

    def save(self):
        f = open(self.uvinput_file, "w")
        f.write(self.uvinput)
        f.close()

    def uvspec(self):
        self.save()
        lamb, rad = iouvspec.uvspec_form1(self.uvinput_file)
        return lamb, rad

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='iouvspec')
    parser.add_argument(
        '-i', nargs=1, default=["input/template.INP"], help="template uvinput file", type=str)
    args = parser.parse_args()

    default_uvinput = args.i[0]
    librad = LibRadtran(args.i[0],"temp_wc","temp_wg")
    # set SIMPLE wcfile
    z = [4.0, 3.0, 2.0]
    lwc = [0.0, 1.0, 1.0]
    reff = [10.0, 10.0, 10.0]

    librad.savewc(z,lwc,reff)
